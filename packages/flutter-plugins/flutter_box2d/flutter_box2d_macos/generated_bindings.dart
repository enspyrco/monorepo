// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for Box2D & Liquidfun
class Box2DBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Box2DBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Box2DBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Default allocation functions
  ffi.Pointer<ffi.Void> b2Alloc_Default(
    int size,
  ) {
    return _b2Alloc_Default(
      size,
    );
  }

  late final _b2Alloc_DefaultPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(int32)>>(
          'b2Alloc_Default');
  late final _b2Alloc_Default =
      _b2Alloc_DefaultPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  void b2Free_Default(
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _b2Free_Default(
      mem,
    );
  }

  late final _b2Free_DefaultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'b2Free_Default');
  late final _b2Free_Default =
      _b2Free_DefaultPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Set alloc and free callbacks to override the default behavior of using
  /// malloc() and free() for dynamic memory allocation.
  /// Set allocCallback and freeCallback to nullptr to restore the default
  /// allocator (malloc / free).
  void b2SetAllocFreeCallbacks(
    b2AllocFunction allocCallback,
    b2FreeFunction freeCallback,
    ffi.Pointer<ffi.Void> callbackData,
  ) {
    return _b2SetAllocFreeCallbacks(
      allocCallback,
      freeCallback,
      callbackData,
    );
  }

  late final _b2SetAllocFreeCallbacksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(b2AllocFunction, b2FreeFunction,
              ffi.Pointer<ffi.Void>)>>('b2SetAllocFreeCallbacks');
  late final _b2SetAllocFreeCallbacks = _b2SetAllocFreeCallbacksPtr.asFunction<
      void Function(b2AllocFunction, b2FreeFunction, ffi.Pointer<ffi.Void>)>();

  /// Set the number of calls to b2Alloc minus the number of calls to b2Free.
  /// This can be used to disable the empty heap check in
  /// b2SetAllocFreeCallbacks() which can be useful for testing.
  void b2SetNumAllocs(
    int numAllocs,
  ) {
    return _b2SetNumAllocs(
      numAllocs,
    );
  }

  late final _b2SetNumAllocsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(int32)>>('b2SetNumAllocs');
  late final _b2SetNumAllocs =
      _b2SetNumAllocsPtr.asFunction<void Function(int)>();

  /// Get number of calls to b2Alloc minus number of calls to b2Free.
  int b2GetNumAllocs() {
    return _b2GetNumAllocs();
  }

  late final _b2GetNumAllocsPtr =
      _lookup<ffi.NativeFunction<int32 Function()>>('b2GetNumAllocs');
  late final _b2GetNumAllocs = _b2GetNumAllocsPtr.asFunction<int Function()>();

  /// Default logging function
  void b2Log_Default(
    ffi.Pointer<ffi.Int8> string,
    va_list args,
  ) {
    return _b2Log_Default(
      string,
      args,
    );
  }

  late final _b2Log_DefaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int8>, va_list)>>('b2Log_Default');
  late final _b2Log_Default = _b2Log_DefaultPtr
      .asFunction<void Function(ffi.Pointer<ffi.Int8>, va_list)>();

  /// Dump to a file. Only one dump file allowed at a time.
  void b2OpenDump(
    ffi.Pointer<ffi.Int8> fileName,
  ) {
    return _b2OpenDump(
      fileName,
    );
  }

  late final _b2OpenDumpPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int8>)>>(
          'b2OpenDump');
  late final _b2OpenDump =
      _b2OpenDumpPtr.asFunction<void Function(ffi.Pointer<ffi.Int8>)>();

  void b2Dump(
    ffi.Pointer<ffi.Int8> string,
  ) {
    return _b2Dump(
      string,
    );
  }

  late final _b2DumpPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int8>)>>(
          'b2Dump');
  late final _b2Dump =
      _b2DumpPtr.asFunction<void Function(ffi.Pointer<ffi.Int8>)>();

  void b2CloseDump() {
    return _b2CloseDump();
  }

  late final _b2CloseDumpPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('b2CloseDump');
  late final _b2CloseDump = _b2CloseDumpPtr.asFunction<void Function()>();

  /// Current version.
  /// Version of Box2D, LiquidFun is based upon.
  late final ffi.Pointer<b2Version> _b2_version =
      _lookup<b2Version>('b2_version');

  b2Version get b2_version => _b2_version.ref;

  /// Global variable is used to identify the version of LiquidFun.
  late final ffi.Pointer<b2Version> _b2_liquidFunVersion =
      _lookup<b2Version>('b2_liquidFunVersion');

  b2Version get b2_liquidFunVersion => _b2_liquidFunVersion.ref;

  /// String which identifies the current version of LiquidFun.
  /// b2_liquidFunVersionString is used by Google developers to identify which
  /// applications uploaded to Google Play are using this library.  This allows
  /// the development team at Google to determine the popularity of the library.
  /// How it works: Applications that are uploaded to the Google Play Store are
  /// scanned for this version string.  We track which applications are using it
  /// to measure popularity.  You are free to remove it (of course) but we would
  /// appreciate if you left it in.
  late final ffi.Pointer<ffi.Pointer<ffi.Int8>> _b2_liquidFunVersionString =
      _lookup<ffi.Pointer<ffi.Int8>>('b2_liquidFunVersionString');

  ffi.Pointer<ffi.Int8> get b2_liquidFunVersionString =>
      _b2_liquidFunVersionString.value;

  set b2_liquidFunVersionString(ffi.Pointer<ffi.Int8> value) =>
      _b2_liquidFunVersionString.value = value;

  /// Add a float to a vector.
  late final ffi.Pointer<b2Vec2> _operator1 = _lookup<b2Vec2>('operator');

  b2Vec2 get operator1 => _operator1.ref;

  /// Useful constant
  late final ffi.Pointer<b2Vec2> _b2Vec2_zero = _lookup<b2Vec2>('b2Vec2_zero');

  b2Vec2 get b2Vec2_zero => _b2Vec2_zero.ref;

  late final ffi.Pointer<ffi.Int32> _b2ParticleGroup =
      _lookup<ffi.Int32>('b2ParticleGroup');

  int get b2ParticleGroup => _b2ParticleGroup.value;

  set b2ParticleGroup(int value) => _b2ParticleGroup.value = value;

  /// Small color object for each particle
  late final ffi.Pointer<ffi.Int32> _b2ParticleColor =
      _lookup<ffi.Int32>('b2ParticleColor');

  int get b2ParticleColor => _b2ParticleColor.value;

  set b2ParticleColor(int value) => _b2ParticleColor.value = value;

  late final ffi.Pointer<ffi.Int32> _b2ParticleColor_zero =
      _lookup<ffi.Int32>('b2ParticleColor_zero');

  int get b2ParticleColor_zero => _b2ParticleColor_zero.value;

  set b2ParticleColor_zero(int value) => _b2ParticleColor_zero.value = value;

  /// A helper function to calculate the optimal number of iterations.
  int b2CalculateParticleIterations(
    double gravity,
    double radius,
    double timeStep,
  ) {
    return _b2CalculateParticleIterations(
      gravity,
      radius,
      timeStep,
    );
  }

  late final _b2CalculateParticleIterationsPtr = _lookup<
          ffi.NativeFunction<int32 Function(ffi.Float, ffi.Float, ffi.Float)>>(
      'b2CalculateParticleIterations');
  late final _b2CalculateParticleIterations = _b2CalculateParticleIterationsPtr
      .asFunction<int Function(double, double, double)>();

  /// Handle to a particle. Particle indices are ephemeral: the same index might
  /// refer to a different particle, from frame-to-frame. If you need to keep a
  /// reference to a particular particle across frames, you should acquire a
  /// b2ParticleHandle. Use #b2ParticleSystem::GetParticleHandleFromIndex() to
  /// retrieve the b2ParticleHandle of a particle from the particle system.
  late final ffi.Pointer<ffi.Int32> _b2ParticleHandle =
      _lookup<ffi.Int32>('b2ParticleHandle');

  int get b2ParticleHandle => _b2ParticleHandle.value;

  set b2ParticleHandle(int value) => _b2ParticleHandle.value = value;

  late final ffi.Pointer<ffi.Int32> _b2TypedIntrusiveListNode =
      _lookup<ffi.Int32>('b2TypedIntrusiveListNode');

  int get b2TypedIntrusiveListNode => _b2TypedIntrusiveListNode.value;

  set b2TypedIntrusiveListNode(int value) =>
      _b2TypedIntrusiveListNode.value = value;

  /// Implement and register this class with a b2World to provide debug drawing of physics
  /// entities in your game.
  late final ffi.Pointer<ffi.Int32> _b2Draw = _lookup<ffi.Int32>('b2Draw');

  int get b2Draw => _b2Draw.value;

  set b2Draw(int value) => _b2Draw.value = value;

  /// Calculates min/max/mean of a set of samples
  late final ffi.Pointer<ffi.Int32> _b2Stat = _lookup<ffi.Int32>('b2Stat');

  int get b2Stat => _b2Stat.value;

  set b2Stat(int value) => _b2Stat.value = value;

  /// Timer for profiling. This has platform specific code and may
  /// not work on every platform.
  late final ffi.Pointer<ffi.Int32> _b2Timer = _lookup<ffi.Int32>('b2Timer');

  int get b2Timer => _b2Timer.value;

  set b2Timer(int value) => _b2Timer.value = value;

  /// @file
  /// Structures and functions used for computing contact points, distance
  /// queries, and TOI queries.
  late final ffi.Pointer<ffi.Int32> _b2Shape = _lookup<ffi.Int32>('b2Shape');

  int get b2Shape => _b2Shape.value;

  set b2Shape(int value) => _b2Shape.value = value;

  late final ffi.Pointer<ffi.Int32> _b2CircleShape =
      _lookup<ffi.Int32>('b2CircleShape');

  int get b2CircleShape => _b2CircleShape.value;

  set b2CircleShape(int value) => _b2CircleShape.value = value;

  late final ffi.Pointer<ffi.Int32> _b2EdgeShape =
      _lookup<ffi.Int32>('b2EdgeShape');

  int get b2EdgeShape => _b2EdgeShape.value;

  set b2EdgeShape(int value) => _b2EdgeShape.value = value;

  late final ffi.Pointer<ffi.Int32> _b2PolygonShape =
      _lookup<ffi.Int32>('b2PolygonShape');

  int get b2PolygonShape => _b2PolygonShape.value;

  set b2PolygonShape(int value) => _b2PolygonShape.value = value;

  late final ffi.Pointer<uint8> _b2_nullFeature =
      _lookup<uint8>('b2_nullFeature');

  int get b2_nullFeature => _b2_nullFeature.value;

  set b2_nullFeature(int value) => _b2_nullFeature.value = value;

  /// Compute the point states given two manifolds. The states pertain to the transition from manifold1
  /// to manifold2. So state1 is either persist or remove while state2 is either add or persist.
  void b2GetPointStates(
    ffi.Pointer<ffi.Int32> state1,
    ffi.Pointer<ffi.Int32> state2,
    ffi.Pointer<b2Manifold> manifold1,
    ffi.Pointer<b2Manifold> manifold2,
  ) {
    return _b2GetPointStates(
      state1,
      state2,
      manifold1,
      manifold2,
    );
  }

  late final _b2GetPointStatesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<b2Manifold>,
              ffi.Pointer<b2Manifold>)>>('b2GetPointStates');
  late final _b2GetPointStates = _b2GetPointStatesPtr.asFunction<
      void Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<b2Manifold>, ffi.Pointer<b2Manifold>)>();

  /// Compute the collision manifold between two circles.
  void b2CollideCircles(
    ffi.Pointer<b2Manifold> manifold,
    ffi.Pointer<ffi.Int32> circleA,
    b2Transform arg2,
  ) {
    return _b2CollideCircles(
      manifold,
      circleA,
      arg2,
    );
  }

  late final _b2CollideCirclesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<b2Manifold>, ffi.Pointer<ffi.Int32>,
              b2Transform)>>('b2CollideCircles');
  late final _b2CollideCircles = _b2CollideCirclesPtr.asFunction<
      void Function(
          ffi.Pointer<b2Manifold>, ffi.Pointer<ffi.Int32>, b2Transform)>();

  /// Compute the collision manifold between a polygon and a circle.
  void b2CollidePolygonAndCircle(
    ffi.Pointer<b2Manifold> manifold,
    ffi.Pointer<ffi.Int32> polygonA,
    b2Transform arg2,
  ) {
    return _b2CollidePolygonAndCircle(
      manifold,
      polygonA,
      arg2,
    );
  }

  late final _b2CollidePolygonAndCirclePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<b2Manifold>, ffi.Pointer<ffi.Int32>,
              b2Transform)>>('b2CollidePolygonAndCircle');
  late final _b2CollidePolygonAndCircle =
      _b2CollidePolygonAndCirclePtr.asFunction<
          void Function(
              ffi.Pointer<b2Manifold>, ffi.Pointer<ffi.Int32>, b2Transform)>();

  /// Compute the collision manifold between two polygons.
  void b2CollidePolygons(
    ffi.Pointer<b2Manifold> manifold,
    ffi.Pointer<ffi.Int32> polygonA,
    b2Transform arg2,
  ) {
    return _b2CollidePolygons(
      manifold,
      polygonA,
      arg2,
    );
  }

  late final _b2CollidePolygonsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<b2Manifold>, ffi.Pointer<ffi.Int32>,
              b2Transform)>>('b2CollidePolygons');
  late final _b2CollidePolygons = _b2CollidePolygonsPtr.asFunction<
      void Function(
          ffi.Pointer<b2Manifold>, ffi.Pointer<ffi.Int32>, b2Transform)>();

  /// Compute the collision manifold between an edge and a circle.
  void b2CollideEdgeAndCircle(
    ffi.Pointer<b2Manifold> manifold,
    ffi.Pointer<ffi.Int32> polygonA,
    b2Transform arg2,
  ) {
    return _b2CollideEdgeAndCircle(
      manifold,
      polygonA,
      arg2,
    );
  }

  late final _b2CollideEdgeAndCirclePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<b2Manifold>, ffi.Pointer<ffi.Int32>,
              b2Transform)>>('b2CollideEdgeAndCircle');
  late final _b2CollideEdgeAndCircle = _b2CollideEdgeAndCirclePtr.asFunction<
      void Function(
          ffi.Pointer<b2Manifold>, ffi.Pointer<ffi.Int32>, b2Transform)>();

  /// Compute the collision manifold between an edge and a polygon.
  void b2CollideEdgeAndPolygon(
    ffi.Pointer<b2Manifold> manifold,
    ffi.Pointer<ffi.Int32> edgeA,
    b2Transform arg2,
  ) {
    return _b2CollideEdgeAndPolygon(
      manifold,
      edgeA,
      arg2,
    );
  }

  late final _b2CollideEdgeAndPolygonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<b2Manifold>, ffi.Pointer<ffi.Int32>,
              b2Transform)>>('b2CollideEdgeAndPolygon');
  late final _b2CollideEdgeAndPolygon = _b2CollideEdgeAndPolygonPtr.asFunction<
      void Function(
          ffi.Pointer<b2Manifold>, ffi.Pointer<ffi.Int32>, b2Transform)>();

  /// Clipping for contact manifolds.
  int b2ClipSegmentToLine(
    ffi.Pointer<b2ClipVertex> vOut,
    ffi.Pointer<b2ClipVertex> vIn,
    b2Vec2 arg2,
  ) {
    return _b2ClipSegmentToLine(
      vOut,
      vIn,
      arg2,
    );
  }

  late final _b2ClipSegmentToLinePtr = _lookup<
      ffi.NativeFunction<
          int32 Function(ffi.Pointer<b2ClipVertex>, ffi.Pointer<b2ClipVertex>,
              b2Vec2)>>('b2ClipSegmentToLine');
  late final _b2ClipSegmentToLine = _b2ClipSegmentToLinePtr.asFunction<
      int Function(
          ffi.Pointer<b2ClipVertex>, ffi.Pointer<b2ClipVertex>, b2Vec2)>();

  /// Determine if two generic shapes overlap.
  int b2TestOverlap(
    ffi.Pointer<ffi.Int32> shapeA,
    int indexA,
    ffi.Pointer<ffi.Int32> shapeB,
    int indexB,
    b2Transform arg4,
  ) {
    return _b2TestOverlap(
      shapeA,
      indexA,
      shapeB,
      indexB,
      arg4,
    );
  }

  late final _b2TestOverlapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int32>, int32,
              ffi.Pointer<ffi.Int32>, int32, b2Transform)>>('b2TestOverlap');
  late final _b2TestOverlap = _b2TestOverlapPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>, int, ffi.Pointer<ffi.Int32>, int,
          b2Transform)>();

  late final ffi.Pointer<ffi.Int32> _b2AABB1 = _lookup<ffi.Int32>('b2AABB');

  int get b2AABB1 => _b2AABB1.value;

  set b2AABB1(int value) => _b2AABB1.value = value;

  late final ffi.Pointer<ffi.Int32> _b2BlockAllocator =
      _lookup<ffi.Int32>('b2BlockAllocator');

  int get b2BlockAllocator => _b2BlockAllocator.value;

  set b2BlockAllocator(int value) => _b2BlockAllocator.value = value;

  /// A chain shape is a free form sequence of line segments.
  /// The chain has one-sided collision, with the surface normal pointing to the right of the edge.
  /// This provides a counter-clockwise winding like the polygon shape.
  /// Connectivity information is used to create smooth collisions.
  /// @warning the chain will not collide properly if there are self-intersections.
  late final ffi.Pointer<ffi.Int32> _b2ChainShape =
      _lookup<ffi.Int32>('b2ChainShape');

  int get b2ChainShape => _b2ChainShape.value;

  set b2ChainShape(int value) => _b2ChainShape.value = value;

  /// A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt.
  /// A dynamic tree arranges data in a binary tree to accelerate
  /// queries such as volume queries and ray casts. Leafs are proxies
  /// with an AABB. In the tree we expand the proxy AABB by b2_fatAABBFactor
  /// so that the proxy AABB is bigger than the client object. This allows the client
  /// object to move by small amounts without triggering a tree update.
  ///
  /// Nodes are pooled and relocatable, so we use node indices rather than pointers.
  late final ffi.Pointer<ffi.Int32> _b2DynamicTree =
      _lookup<ffi.Int32>('b2DynamicTree');

  int get b2DynamicTree => _b2DynamicTree.value;

  set b2DynamicTree(int value) => _b2DynamicTree.value = value;

  /// The broad-phase is used for computing pairs and performing volume queries and ray casts.
  /// This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
  /// It is up to the client to consume the new pairs and to track subsequent overlap.
  late final ffi.Pointer<ffi.Int32> _b2BroadPhase =
      _lookup<ffi.Int32>('b2BroadPhase');

  int get b2BroadPhase => _b2BroadPhase.value;

  set b2BroadPhase(int value) => _b2BroadPhase.value = value;

  late final ffi.Pointer<ffi.Int32> _b2Fixture =
      _lookup<ffi.Int32>('b2Fixture');

  int get b2Fixture => _b2Fixture.value;

  set b2Fixture(int value) => _b2Fixture.value = value;

  late final ffi.Pointer<ffi.Int32> _b2Joint = _lookup<ffi.Int32>('b2Joint');

  int get b2Joint => _b2Joint.value;

  set b2Joint(int value) => _b2Joint.value = value;

  late final ffi.Pointer<ffi.Int32> _b2Contact =
      _lookup<ffi.Int32>('b2Contact');

  int get b2Contact => _b2Contact.value;

  set b2Contact(int value) => _b2Contact.value = value;

  late final ffi.Pointer<ffi.Int32> _b2Controller =
      _lookup<ffi.Int32>('b2Controller');

  int get b2Controller => _b2Controller.value;

  set b2Controller(int value) => _b2Controller.value = value;

  late final ffi.Pointer<ffi.Int32> _b2World = _lookup<ffi.Int32>('b2World');

  int get b2World => _b2World.value;

  set b2World(int value) => _b2World.value = value;

  /// A rigid body. These are created via b2World::CreateBody.
  late final ffi.Pointer<ffi.Int32> _b2Body = _lookup<ffi.Int32>('b2Body');

  int get b2Body => _b2Body.value;

  set b2Body(int value) => _b2Body.value = value;

  late final ffi.Pointer<ffi.Int32> _b2StackAllocator =
      _lookup<ffi.Int32>('b2StackAllocator');

  int get b2StackAllocator => _b2StackAllocator.value;

  set b2StackAllocator(int value) => _b2StackAllocator.value = value;

  late final ffi.Pointer<ffi.Int32> _b2ContactListener =
      _lookup<ffi.Int32>('b2ContactListener');

  int get b2ContactListener => _b2ContactListener.value;

  set b2ContactListener(int value) => _b2ContactListener.value = value;

  /// Alignment (in bytes) of user memory associated with b2TrackedBlock.
  late final ffi.Pointer<int32> _b2_mallocAlignment =
      _lookup<int32>('b2_mallocAlignment');

  int get b2_mallocAlignment => _b2_mallocAlignment.value;

  set b2_mallocAlignment(int value) => _b2_mallocAlignment.value = value;

  /// Allocated block of memory that can be tracked in a b2IntrusiveList.
  late final ffi.Pointer<ffi.Int32> _b2TrackedBlock =
      _lookup<ffi.Int32>('b2TrackedBlock');

  int get b2TrackedBlock => _b2TrackedBlock.value;

  set b2TrackedBlock(int value) => _b2TrackedBlock.value = value;

  /// Allocator of blocks which are tracked in a list.
  late final ffi.Pointer<ffi.Int32> _b2TrackedBlockAllocator =
      _lookup<ffi.Int32>('b2TrackedBlockAllocator');

  int get b2TrackedBlockAllocator => _b2TrackedBlockAllocator.value;

  set b2TrackedBlockAllocator(int value) =>
      _b2TrackedBlockAllocator.value = value;

  late final ffi.Pointer<int32> _b2_blockSizeCount =
      _lookup<int32>('b2_blockSizeCount');

  int get b2_blockSizeCount => _b2_blockSizeCount.value;

  set b2_blockSizeCount(int value) => _b2_blockSizeCount.value = value;

  late final ffi.Pointer<ffi.Int32> _b2ContactFilter =
      _lookup<ffi.Int32>('b2ContactFilter');

  int get b2ContactFilter => _b2ContactFilter.value;

  set b2ContactFilter(int value) => _b2ContactFilter.value = value;

  late final ffi.Pointer<ffi.Int32> _b2ParticleSystem =
      _lookup<ffi.Int32>('b2ParticleSystem');

  int get b2ParticleSystem => _b2ParticleSystem.value;

  set b2ParticleSystem(int value) => _b2ParticleSystem.value = value;

  late final ffi.Pointer<ffi.Int32> _b2ContactManager =
      _lookup<ffi.Int32>('b2ContactManager');

  int get b2ContactManager => _b2ContactManager.value;

  set b2ContactManager(int value) => _b2ContactManager.value = value;

  late final ffi.Pointer<int32> _b2_stackSize = _lookup<int32>('b2_stackSize');

  int get b2_stackSize => _b2_stackSize.value;

  set b2_stackSize(int value) => _b2_stackSize.value = value;

  late final ffi.Pointer<int32> _b2_maxStackEntries =
      _lookup<int32>('b2_maxStackEntries');

  int get b2_maxStackEntries => _b2_maxStackEntries.value;

  set b2_maxStackEntries(int value) => _b2_maxStackEntries.value = value;

  /// Joints and fixtures are destroyed when their associated
  /// body is destroyed. Implement this listener so that you
  /// may nullify references to these joints and shapes.
  late final ffi.Pointer<ffi.Int32> _b2DestructionListener =
      _lookup<ffi.Int32>('b2DestructionListener');

  int get b2DestructionListener => _b2DestructionListener.value;

  set b2DestructionListener(int value) => _b2DestructionListener.value = value;

  /// Callback class for AABB queries.
  /// See b2World::Query
  late final ffi.Pointer<ffi.Int32> _b2QueryCallback =
      _lookup<ffi.Int32>('b2QueryCallback');

  int get b2QueryCallback => _b2QueryCallback.value;

  set b2QueryCallback(int value) => _b2QueryCallback.value = value;

  /// Callback class for ray casts.
  /// See b2World::RayCast
  late final ffi.Pointer<ffi.Int32> _b2RayCastCallback =
      _lookup<ffi.Int32>('b2RayCastCallback');

  int get b2RayCastCallback => _b2RayCastCallback.value;

  set b2RayCastCallback(int value) => _b2RayCastCallback.value = value;

  /// Fast - O(1) - list based allocator for items that can be inserted into
  /// b2IntrusiveListNode lists.
  late final ffi.Pointer<ffi.Int32> _b2FreeList =
      _lookup<ffi.Int32>('b2FreeList');

  int get b2FreeList => _b2FreeList.value;

  set b2FreeList(int value) => _b2FreeList.value = value;

  late final ffi.Pointer<ffi.Int32> _b2ParticlePairSet =
      _lookup<ffi.Int32>('b2ParticlePairSet');

  int get b2ParticlePairSet => _b2ParticlePairSet.value;

  set b2ParticlePairSet(int value) => _b2ParticlePairSet.value = value;

  late final ffi.Pointer<ffi.Int32> _FixtureParticleSet =
      _lookup<ffi.Int32>('FixtureParticleSet');

  int get FixtureParticleSet => _FixtureParticleSet.value;

  set FixtureParticleSet(int value) => _FixtureParticleSet.value = value;

  late final ffi.Pointer<ffi.Void> _b2ParticleContact1 =
      _lookup<ffi.Void>('b2ParticleContact');

  void get b2ParticleContact1 => _b2ParticleContact1.value;

  set b2ParticleContact1(void value) => _b2ParticleContact1.value = value;

  /// Utility to compute linear stiffness values from frequency and damping ratio
  void b2LinearStiffness(
    double arg0,
  ) {
    return _b2LinearStiffness(
      arg0,
    );
  }

  late final _b2LinearStiffnessPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Float)>>(
          'b2LinearStiffness');
  late final _b2LinearStiffness =
      _b2LinearStiffnessPtr.asFunction<void Function(double)>();

  /// Utility to compute rotational stiffness values frequency and damping ratio
  void b2AngularStiffness(
    double arg0,
  ) {
    return _b2AngularStiffness(
      arg0,
    );
  }

  late final _b2AngularStiffnessPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Float)>>(
          'b2AngularStiffness');
  late final _b2AngularStiffness =
      _b2AngularStiffnessPtr.asFunction<void Function(double)>();

  /// A distance joint constrains two points on two bodies to remain at a fixed
  /// distance from each other. You can view this as a massless, rigid rod.
  late final ffi.Pointer<ffi.Int32> _b2DistanceJoint =
      _lookup<ffi.Int32>('b2DistanceJoint');

  int get b2DistanceJoint => _b2DistanceJoint.value;

  set b2DistanceJoint(int value) => _b2DistanceJoint.value = value;

  /// Friction joint. This is used for top-down friction.
  /// It provides 2D translational friction and angular friction.
  late final ffi.Pointer<ffi.Int32> _b2FrictionJoint =
      _lookup<ffi.Int32>('b2FrictionJoint');

  int get b2FrictionJoint => _b2FrictionJoint.value;

  set b2FrictionJoint(int value) => _b2FrictionJoint.value = value;

  /// A gear joint is used to connect two joints together. Either joint
  /// can be a revolute or prismatic joint. You specify a gear ratio
  /// to bind the motions together:
  /// coordinate1 + ratio * coordinate2 = constant
  /// The ratio can be negative or positive. If one joint is a revolute joint
  /// and the other joint is a prismatic joint, then the ratio will have units
  /// of length or units of 1/length.
  /// @warning You have to manually destroy the gear joint if joint1 or joint2
  /// is destroyed.
  late final ffi.Pointer<ffi.Int32> _b2GearJoint =
      _lookup<ffi.Int32>('b2GearJoint');

  int get b2GearJoint => _b2GearJoint.value;

  set b2GearJoint(int value) => _b2GearJoint.value = value;

  /// A motor joint is used to control the relative motion
  /// between two bodies. A typical usage is to control the movement
  /// of a dynamic body with respect to the ground.
  late final ffi.Pointer<ffi.Int32> _b2MotorJoint =
      _lookup<ffi.Int32>('b2MotorJoint');

  int get b2MotorJoint => _b2MotorJoint.value;

  set b2MotorJoint(int value) => _b2MotorJoint.value = value;

  /// A mouse joint is used to make a point on a body track a
  /// specified world point. This a soft constraint with a maximum
  /// force. This allows the constraint to stretch and without
  /// applying huge forces.
  /// NOTE: this joint is not documented in the manual because it was
  /// developed to be used in the testbed. If you want to learn how to
  /// use the mouse joint, look at the testbed.
  late final ffi.Pointer<ffi.Int32> _b2MouseJoint =
      _lookup<ffi.Int32>('b2MouseJoint');

  int get b2MouseJoint => _b2MouseJoint.value;

  set b2MouseJoint(int value) => _b2MouseJoint.value = value;

  /// A prismatic joint. This joint provides one degree of freedom: translation
  /// along an axis fixed in bodyA. Relative rotation is prevented. You can
  /// use a joint limit to restrict the range of motion and a joint motor to
  /// drive the motion or to model joint friction.
  late final ffi.Pointer<ffi.Int32> _b2PrismaticJoint =
      _lookup<ffi.Int32>('b2PrismaticJoint');

  int get b2PrismaticJoint => _b2PrismaticJoint.value;

  set b2PrismaticJoint(int value) => _b2PrismaticJoint.value = value;

  late final ffi.Pointer<ffi.Float> _b2_minPulleyLength =
      _lookup<ffi.Float>('b2_minPulleyLength');

  double get b2_minPulleyLength => _b2_minPulleyLength.value;

  set b2_minPulleyLength(double value) => _b2_minPulleyLength.value = value;

  /// The pulley joint is connected to two bodies and two fixed ground points.
  /// The pulley supports a ratio such that:
  /// length1 + ratio * length2 <= constant
  /// Yes, the force transmitted is scaled by the ratio.
  /// Warning: the pulley joint can get a bit squirrelly by itself. They often
  /// work better when combined with prismatic joints. You should also cover the
  /// the anchor points with static shapes to prevent one side from going to
  /// zero length.
  late final ffi.Pointer<ffi.Int32> _b2PulleyJoint =
      _lookup<ffi.Int32>('b2PulleyJoint');

  int get b2PulleyJoint => _b2PulleyJoint.value;

  set b2PulleyJoint(int value) => _b2PulleyJoint.value = value;

  /// A revolute joint constrains two bodies to share a common point while they
  /// are free to rotate about the point. The relative rotation about the shared
  /// point is the joint angle. You can limit the relative rotation with
  /// a joint limit that specifies a lower and upper angle. You can use a motor
  /// to drive the relative rotation about the shared point. A maximum motor torque
  /// is provided so that infinite forces are not generated.
  late final ffi.Pointer<ffi.Int32> _b2RevoluteJoint =
      _lookup<ffi.Int32>('b2RevoluteJoint');

  int get b2RevoluteJoint => _b2RevoluteJoint.value;

  set b2RevoluteJoint(int value) => _b2RevoluteJoint.value = value;

  /// A weld joint essentially glues two bodies together. A weld joint may
  /// distort somewhat because the island constraint solver is approximate.
  late final ffi.Pointer<ffi.Int32> _b2WeldJoint =
      _lookup<ffi.Int32>('b2WeldJoint');

  int get b2WeldJoint => _b2WeldJoint.value;

  set b2WeldJoint(int value) => _b2WeldJoint.value = value;

  /// A wheel joint. This joint provides two degrees of freedom: translation
  /// along an axis fixed in bodyA and rotation in the plane. In other words, it is a point to
  /// line constraint with a rotational motor and a linear spring/damper. The spring/damper is
  /// initialized upon creation. This joint is designed for vehicle suspensions.
  late final ffi.Pointer<ffi.Int32> _b2WheelJoint =
      _lookup<ffi.Int32>('b2WheelJoint');

  int get b2WheelJoint => _b2WheelJoint.value;

  set b2WheelJoint(int value) => _b2WheelJoint.value = value;

  ///
  late final ffi.Pointer<ffi.Int32> _b2Rope = _lookup<ffi.Int32>('b2Rope');

  int get b2Rope => _b2Rope.value;

  set b2Rope(int value) => _b2Rope.value = value;

  /// A field representing the nearest generator from each point.
  late final ffi.Pointer<ffi.Int32> _b2VoronoiDiagram =
      _lookup<ffi.Int32>('b2VoronoiDiagram');

  int get b2VoronoiDiagram => _b2VoronoiDiagram.value;

  set b2VoronoiDiagram(int value) => _b2VoronoiDiagram.value = value;

  void array_bounds_check(
    int array_size,
    int array_idx,
  ) {
    return _array_bounds_check(
      array_size,
      array_idx,
    );
  }

  late final _array_bounds_checkPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Int32)>>(
          'array_bounds_check');
  late final _array_bounds_check =
      _array_bounds_checkPtr.asFunction<void Function(int, int)>();
}

/// You can define this to inject whatever data you want in b2Body
class b2BodyUserData extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2BodyUserData1;
}

/// You can define this to inject whatever data you want in b2Fixture
class b2FixtureUserData extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2FixtureUserData1;
}

/// You can define this to inject whatever data you want in b2Joint
class b2JointUserData extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2JointUserData1;
}

typedef int32 = ffi.Int32;

/// Use this function to override b2Alloc() without recompiling this library.
typedef b2AllocFunction = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(int32, ffi.Pointer<ffi.Void>)>>;

/// Use this function to override b2Free() without recompiling this library.
typedef b2FreeFunction = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;
typedef va_list = __builtin_va_list;
typedef __builtin_va_list = ffi.Pointer<ffi.Int8>;

/// Version numbering scheme.
/// See http://en.wikipedia.org/wiki/Software_versioning
class b2Version extends ffi.Struct {
  /// < significant changes
  @int32()
  external int major;

  /// < incremental changes
  @int32()
  external int minor;

  /// < bug fixes
  @int32()
  external int revision;
}

/// A 2D column vector.
class b2Vec2 extends ffi.Struct {
  /// Default constructor does nothing (for performance).
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2Vec21;
}

/// A 4D column vector with 4 elements.
class b2Vec4 extends ffi.Struct {
  /// Default constructor does nothing (for performance).
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2Vec41;
}

/// A 2-by-2 matrix. Stored in column-major order.
class b2Mat22 extends ffi.Struct {
  /// The default constructor does nothing (for performance).
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2Mat221;
}

/// A 3-by-3 matrix. Stored in column-major order.
class b2Mat33 extends ffi.Struct {
  /// The default constructor does nothing (for performance).
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2Mat331;

  /// Solve A * x = b, where b is a column vector. This is more efficient
  /// than computing the inverse in one-shot cases. Solve only the upper
  /// 2-by-2 matrix equation.
  external ffi.NativeFunction<b2Vec2 Function(b2Vec2)> Solve22;

  /// Get the inverse of this matrix as a 2-by-2.
  /// Returns the zero matrix if singular.
  @ffi.NativeFunction<ffi.Void Function(ffi.Pointer<b2Mat33>)>()
  external ffi.NativeFunction<void Function(ffi.Pointer<b2Mat33>)> GetInverse22;

  /// Get the symmetric inverse of this matrix as a 3-by-3.
  /// Returns the zero matrix if singular.
  @ffi.NativeFunction<ffi.Void Function(ffi.Pointer<b2Mat33>)>()
  external ffi.NativeFunction<void Function(ffi.Pointer<b2Mat33>)>
      GetSymInverse33;

  @ffi.Int32()
  external int ex;

  @ffi.Int32()
  external int ey;

  @ffi.Int32()
  external int ez;
}

/// Rotation
class b2Rot extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2Rot1;
}

/// A transform contains translation and rotation. It is used to represent
/// the position and orientation of rigid frames.
class b2Transform extends ffi.Struct {
  /// The default constructor does nothing.
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2Transform1;

  external b2Rot q;
}

/// This describes the motion of a body/shape for TOI computation.
/// Shapes are defined with respect to the body origin, which may
/// no coincide with the center of mass. However, to support dynamics
/// we must interpolate the center of mass position.
class b2Sweep extends ffi.Struct {
  /// Get the interpolated transform at a specific time.
  /// @param transform the output transform
  /// @param beta is a factor in [0,1], where 0 indicates alpha0.
  @ffi.NativeFunction<ffi.Void Function(ffi.Pointer<b2Transform>, ffi.Float)>()
  external ffi.NativeFunction<void Function(ffi.Pointer<b2Transform>, double)>
      GetTransform;

  /// Advance the sweep forward, yielding a new initial state.
  /// @param alpha the new initial time.
  @ffi.NativeFunction<ffi.Void Function(ffi.Float)>()
  external ffi.NativeFunction<void Function(double)> Advance;

  /// Normalize the angles.
  @ffi.NativeFunction<ffi.Void Function()>()
  external ffi.NativeFunction<void Function()> Normalize;

  /// < local center of mass position
  external b2Vec2 localCenter;

  /// < center world positions
  external b2Vec2 c0;

  external b2Vec2 c;

  /// < world angles
  @ffi.Float()
  external double a0;

  @ffi.Float()
  external double a;

  /// Fraction of the current time step in the range [0,1]
  /// c0 and a0 are the positions at alpha0.
  @ffi.Float()
  external double alpha0;
}

/// Color for debug drawing. Each value has the range [0,1].
class b2Color extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2Color1;
}

/// The particle type. Can be combined with the | operator.
abstract class b2ParticleFlag {
  /// Water particle.
  static const int b2_waterParticle = 0;

  /// Removed after next simulation step.
  static const int b2_zombieParticle = 2;

  /// Zero velocity.
  static const int b2_wallParticle = 4;

  /// With restitution from stretching.
  static const int b2_springParticle = 8;

  /// With restitution from deformation.
  static const int b2_elasticParticle = 16;

  /// With viscosity.
  static const int b2_viscousParticle = 32;

  /// Without isotropic pressure.
  static const int b2_powderParticle = 64;

  /// With surface tension.
  static const int b2_tensileParticle = 128;

  /// Mix color between contacting particles.
  static const int b2_colorMixingParticle = 256;

  /// Call b2DestructionListener on destruction.
  static const int b2_destructionListenerParticle = 512;

  /// Prevents other particles from leaking.
  static const int b2_barrierParticle = 1024;

  /// Less compressibility.
  static const int b2_staticPressureParticle = 2048;

  /// Makes pairs or triads with other particles.
  static const int b2_reactiveParticle = 4096;

  /// With high repulsive force.
  static const int b2_repulsiveParticle = 8192;

  /// Call b2ContactListener when this particle is about to interact with
  /// a rigid body or stops interacting with a rigid body.
  /// This results in an expensive operation compared to using
  /// b2_fixtureContactFilterParticle to detect collisions between
  /// particles.
  static const int b2_fixtureContactListenerParticle = 16384;

  /// Call b2ContactListener when this particle is about to interact with
  /// another particle or stops interacting with another particle.
  /// This results in an expensive operation compared to using
  /// b2_particleContactFilterParticle to detect collisions between
  /// particles.
  static const int b2_particleContactListenerParticle = 32768;

  /// Call b2ContactFilter when this particle interacts with rigid bodies.
  static const int b2_fixtureContactFilterParticle = 65536;

  /// Call b2ContactFilter when this particle interacts with other
  /// particles.
  static const int b2_particleContactFilterParticle = 131072;
}

/// A particle definition holds all the data needed to construct a particle.
/// You can safely re-use these definitions.
class b2ParticleDef extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2ParticleDef1;

  /// The world position of the particle.
  external b2Vec2 position;

  /// The linear velocity of the particle in world co-ordinates.
  external b2Vec2 velocity;

  /// The color of the particle.
  @ffi.Int32()
  external int color;

  /// Lifetime of the particle in seconds.  A value <= 0.0f indicates a
  /// particle with infinite lifetime.
  @ffi.Float()
  external double lifetime;

  /// Use this to store application-specific body data.
  external ffi.Pointer<ffi.Void> userData;

  /// An existing particle group to which the particle will be added.
  external ffi.Pointer<ffi.Int32> group;
}

typedef uint8 = ffi.Uint8;

/// The features that intersect to form the contact point
/// This must be 4 bytes or less.
class b2ContactFeature extends ffi.Struct {
  /// < Feature index on shapeA
  @uint8()
  external int indexA;

  /// < Feature index on shapeB
  @uint8()
  external int indexB;

  /// < The feature type on shapeA
  @uint8()
  external int typeA;

  /// < The feature type on shapeB
  @uint8()
  external int typeB;
}

/// Contact ids to facilitate warm starting.
class b2ContactID extends ffi.Union {
  external b2ContactFeature cf;

  /// < Used to quickly compare contact ids.
  @uint32()
  external int key;
}

typedef uint32 = ffi.Uint32;

/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleB
/// -e_faceA: the local center of cirlceB or the clip point of polygonB
/// -e_faceB: the clip point of polygonA
/// This structure is stored across time steps, so we keep it small.
/// Note: the impulses are used for internal caching and may not
/// provide reliable contact forces, especially for high speed collisions.
class b2ManifoldPoint extends ffi.Struct {
  /// < usage depends on manifold type
  external b2Vec2 localPoint;

  /// < the non-penetration impulse
  @ffi.Float()
  external double normalImpulse;

  /// < the friction impulse
  @ffi.Float()
  external double tangentImpulse;

  /// < uniquely identifies a contact point between two shapes
  external b2ContactID id;
}

/// A manifold for two touching convex shapes.
/// Box2D supports multiple types of contact:
/// - clip point versus plane with radius
/// - point versus point with radius (circles)
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleA
/// -e_faceA: the center of faceA
/// -e_faceB: the center of faceB
/// Similarly the local normal usage:
/// -e_circles: not used
/// -e_faceA: the normal on polygonA
/// -e_faceB: the normal on polygonB
/// We store contacts in this way so that position correction can
/// account for movement, which is critical for continuous physics.
/// All contact scenarios must be expressed in one of these types.
/// This structure is stored across time steps, so we keep it small.
class b2Manifold extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<b2ManifoldPoint> points;

  /// < not use for Type::e_points
  external b2Vec2 localNormal;

  /// < usage depends on manifold type
  external b2Vec2 localPoint;

  @ffi.Int32()
  external int type;

  /// < the number of manifold points
  @int32()
  external int pointCount;
}

abstract class Type {
  static const int e_vertex = 0;
  static const int e_face = 1;
}

/// This is used to compute the current state of a contact manifold.
class b2WorldManifold extends ffi.Struct {
  /// Evaluate the manifold with supplied transforms. This assumes
  /// modest motion from the original state. This does not change the
  /// point count, impulses, etc. The radii must come from the shapes
  /// that generated the manifold.
  @ffi.NativeFunction<ffi.Void Function(ffi.Pointer<b2Manifold>, b2Transform)>()
  external ffi
          .NativeFunction<void Function(ffi.Pointer<b2Manifold>, b2Transform)>
      Initialize;

  /// < world vector pointing from A to B
  external b2Vec2 normal;

  @ffi.Array.multi([2])
  external ffi.Array<b2Vec2> points;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> separations;
}

/// This is used for determining the state of contact points.
abstract class b2PointState {
  /// < point does not exist
  static const int b2_nullState = 0;

  /// < point was added in the update
  static const int b2_addState = 1;

  /// < point persisted across the update
  static const int b2_persistState = 2;

  /// < point was removed in the update
  static const int b2_removeState = 3;
}

/// Used for computing contact manifolds.
class b2ClipVertex extends ffi.Struct {
  external b2Vec2 v;

  external b2ContactID id;
}

/// Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
class b2RayCastInput extends ffi.Struct {
  external b2Vec2 p1;

  external b2Vec2 p2;

  @ffi.Float()
  external double maxFraction;
}

/// Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
/// come from b2RayCastInput.
class b2RayCastOutput extends ffi.Struct {
  external b2Vec2 normal;

  @ffi.Float()
  external double fraction;
}

/// An axis aligned bounding box.
class b2AABB extends ffi.Struct {
  /// Verify that the bounds are sorted.
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> IsValid;

  /// Get the center of the AABB.
  external ffi.NativeFunction<b2Vec2 Function()> GetCenter;

  /// < the lower vertex
  external b2Vec2 lowerBound;

  /// < the upper vertex
  external b2Vec2 upperBound;
}

/// This holds the mass data computed for a shape.
class b2MassData extends ffi.Struct {
  /// The mass of the shape, usually in kilograms.
  @ffi.Float()
  external double mass;

  /// The position of the shape's centroid relative to the shape's origin.
  external b2Vec2 center;

  /// The rotational inertia of the shape about the local origin.
  @ffi.Float()
  external double I;
}

/// A node in the dynamic tree. The client does not interact with this directly.
class b2TreeNode extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> IsLeaf;

  external ffi.Pointer<ffi.Void> userData;

  @int32()
  external int child1;

  @int32()
  external int child2;

  @int32()
  external int height;

  @ffi.Int32()
  external int moved;
}

class b2Pair extends ffi.Struct {
  @int32()
  external int proxyIdA;

  @int32()
  external int proxyIdB;
}

/// A fixture definition is used to create a fixture. This class defines an
/// abstract fixture definition. You can reuse fixture definitions safely.
class b2FixtureDef extends ffi.Struct {
  /// The constructor sets the default fixture definition values.
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2FixtureDef1;

  /// Use this to store application specific fixture data.
  external b2FixtureUserData userData;

  /// The friction coefficient, usually in the range [0,1].
  @ffi.Float()
  external double friction;

  /// The restitution (elasticity) usually in the range [0,1].
  @ffi.Float()
  external double restitution;

  /// Restitution velocity threshold, usually in m/s. Collisions above this
  /// speed have restitution applied (will bounce).
  @ffi.Float()
  external double restitutionThreshold;

  /// The density, usually in kg/m^2.
  @ffi.Float()
  external double density;

  /// A sensor shape collects contact information but never generates a collision
  /// response.
  @ffi.Int32()
  external int isSensor;

  /// Contact filtering data.
  external b2Filter filter;
}

/// This holds contact filtering data.
class b2Filter extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2Filter1;

  /// The collision mask bits. This states the categories that this
  /// shape would accept for collision.
  @uint16()
  external int maskBits;

  /// Collision groups allow a certain group of objects to never collide (negative)
  /// or always collide (positive). Zero means no collision group. Non-zero group
  /// filtering always wins against the mask bits.
  @int16()
  external int groupIndex;
}

typedef uint16 = ffi.Uint16;
typedef int16 = ffi.Int16;

/// A joint edge is used to connect bodies and joints together
/// in a joint graph where each body is a node and each joint
/// is an edge. A joint edge belongs to a doubly linked list
/// maintained in each attached body. Each joint has two joint
/// nodes, one for each attached body.
class b2JointEdge extends ffi.Struct {
  /// < provides quick access to the other body attached.
  external ffi.Pointer<ffi.Int32> other;

  /// < the joint
  external ffi.Pointer<ffi.Int32> joint;

  /// < the previous joint edge in the body's joint list
  external ffi.Pointer<b2JointEdge> prev;

  /// < the next joint edge in the body's joint list
  external ffi.Pointer<b2JointEdge> next;
}

/// A contact edge is used to connect bodies and contacts together
/// in a contact graph where each body is a node and each contact
/// is an edge. A contact edge belongs to a doubly linked list
/// maintained in each attached body. Each contact has two contact
/// nodes, one for each attached body.
class b2ContactEdge extends ffi.Struct {
  /// < provides quick access to the other body attached.
  external ffi.Pointer<ffi.Int32> other;

  /// < the contact
  external ffi.Pointer<ffi.Int32> contact;

  /// < the previous contact edge in the body's contact list
  external ffi.Pointer<b2ContactEdge> prev;

  /// < the next contact edge in the body's contact list
  external ffi.Pointer<b2ContactEdge> next;
}

/// The body type.
/// static: zero mass, zero velocity, may be manually moved
/// kinematic: zero mass, non-zero velocity set by user, moved by solver
/// dynamic: positive mass, non-zero velocity determined by forces, moved by solver
abstract class b2BodyType {
  static const int b2_staticBody = 0;
  static const int b2_kinematicBody = 1;
  static const int b2_dynamicBody = 2;
}

/// A body definition holds all the data needed to construct a rigid body.
/// You can safely re-use body definitions. Shapes are added to a body after construction.
class b2BodyDef extends ffi.Struct {
  /// This constructor sets the body definition default values.
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2BodyDef1;

  /// The world position of the body. Avoid creating bodies at the origin
  /// since this can lead to many overlapping shapes.
  external b2Vec2 position;

  /// The world angle of the body in radians.
  @ffi.Float()
  external double angle;

  /// The linear velocity of the body's origin in world co-ordinates.
  external b2Vec2 linearVelocity;

  /// The angular velocity of the body.
  @ffi.Float()
  external double angularVelocity;

  /// Linear damping is use to reduce the linear velocity. The damping parameter
  /// can be larger than 1.0f but the damping effect becomes sensitive to the
  /// time step when the damping parameter is large.
  /// Units are 1/time
  @ffi.Float()
  external double linearDamping;

  /// Angular damping is use to reduce the angular velocity. The damping parameter
  /// can be larger than 1.0f but the damping effect becomes sensitive to the
  /// time step when the damping parameter is large.
  /// Units are 1/time
  @ffi.Float()
  external double angularDamping;

  /// Set this flag to false if this body should never fall asleep. Note that
  /// this increases CPU usage.
  @ffi.Int32()
  external int allowSleep;

  /// Is this body initially awake or sleeping?
  @ffi.Int32()
  external int awake;

  /// Should this body be prevented from rotating? Useful for characters.
  @ffi.Int32()
  external int fixedRotation;

  /// Is this a fast moving body that should be prevented from tunneling through
  /// other moving bodies? Note that all bodies are prevented from tunneling through
  /// kinematic and static bodies. This setting is only considered on dynamic bodies.
  /// @warning You should use this flag sparingly since it increases processing time.
  @ffi.Int32()
  external int bullet;

  /// Does this body start out enabled?
  @ffi.Int32()
  external int enabled;

  /// Use this to store application specific body data.
  external b2BodyUserData userData;

  /// Scale the gravity applied to this body.
  @ffi.Float()
  external double gravityScale;
}

/// This proxy is used internally to connect fixtures to the broad-phase.
class b2FixtureProxy extends ffi.Struct {
  external b2AABB aabb;

  external ffi.Pointer<ffi.Int32> fixture;

  @int32()
  external int childIndex;

  @int32()
  external int proxyId;
}

class b2ContactRegister extends ffi.Struct {
  external ffi.Pointer<b2ContactCreateFcn> createFcn;

  external ffi.Pointer<b2ContactDestroyFcn> destroyFcn;

  @ffi.Int32()
  external int primary;
}

typedef b2ContactCreateFcn = ffi.NativeFunction<
    ffi.Pointer<ffi.Int32> Function(ffi.Pointer<ffi.Int32>, int32,
        ffi.Pointer<ffi.Int32>, int32, ffi.Pointer<ffi.Int32>)>;
typedef b2ContactDestroyFcn = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>;

/// Profiling data. Times are in milliseconds.
class b2Profile extends ffi.Struct {
  @ffi.Float()
  external double step;

  @ffi.Float()
  external double collide;

  @ffi.Float()
  external double solve;

  @ffi.Float()
  external double solveInit;

  @ffi.Float()
  external double solveVelocity;

  @ffi.Float()
  external double solvePosition;

  @ffi.Float()
  external double broadphase;

  @ffi.Float()
  external double solveTOI;
}

/// This is an internal structure.
class b2TimeStep extends ffi.Struct {
  @ffi.Float()
  external double dt;

  @ffi.Float()
  external double inv_dt;

  @ffi.Float()
  external double dtRatio;

  @int32()
  external int velocityIterations;

  @int32()
  external int positionIterations;

  @int32()
  external int particleIterations;

  @ffi.Int32()
  external int warmStarting;
}

/// This is an internal structure.
class b2Position extends ffi.Struct {
  external b2Vec2 c;

  @ffi.Float()
  external double a;
}

/// This is an internal structure.
class b2Velocity extends ffi.Struct {
  external b2Vec2 v;

  @ffi.Float()
  external double w;
}

/// Solver Data
class b2SolverData extends ffi.Struct {
  external b2TimeStep step;

  external ffi.Pointer<b2Position> positions;

  external ffi.Pointer<b2Velocity> velocities;
}

class b2Block extends ffi.Opaque {}

class b2Chunk extends ffi.Opaque {}

class b2StackEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> data;

  @int32()
  external int size;

  @ffi.Int32()
  external int usedMalloc;
}

class b2ContactResult extends ffi.Opaque {}

class b2ParticleBodyContact extends ffi.Struct {
  /// Index of the particle making contact.
  @int32()
  external int index;

  /// The body making contact.
  external ffi.Pointer<ffi.Int32> body;

  /// The specific fixture making contact
  external ffi.Pointer<ffi.Int32> fixture;

  /// Weight of the contact. A value between 0.0f and 1.0f.
  @ffi.Float()
  external double weight;

  /// The normalized direction from the particle to the body.
  external b2Vec2 normal;

  /// The effective mass used in calculating force.
  @ffi.Float()
  external double mass;
}

class b2ParticleContact extends ffi.Struct {
  @ffi.Int32()
  external int private;

  /// Indices of the respective particles making contact.
  @ffi.Int32()
  external int indexA;

  @ffi.Int32()
  external int indexB;

  /// Weight of the contact. A value between 0.0f and 1.0f.
  /// 0.0f ==> particles are just barely touching
  /// 1.0f ==> particles are perfectly on top of each other
  @ffi.Float()
  external double weight;

  /// The normalized direction from A to B.
  external b2Vec2 normal;

  /// The logical sum of the particle behaviors that have been set.
  /// See the b2ParticleFlag enum.
  @uint32()
  external int flags;

  @ffi.Int32()
  external int public;

  @ffi.NativeFunction<ffi.Void Function(ffi.Float)>()
  external ffi.NativeFunction<void Function(double)> SetWeight;

  @ffi.Int32()
  external int operator1;
}

/// Contact impulses for reporting. Impulses are used instead of forces because
/// sub-step forces may approach infinity for rigid body collisions. These
/// match up one-to-one with the contact points in b2Manifold.
class b2ContactImpulse extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> normalImpulses;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> tangentImpulses;

  @int32()
  external int count;
}

/// A particle group definition holds all the data needed to construct a
/// particle group.  You can safely re-use these definitions.
class b2ParticleGroupDef extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2ParticleGroupDef1;

  /// The group-construction flags (See #b2ParticleGroupFlag).
  @uint32()
  external int groupFlags;

  /// The world position of the group.
  /// Moves the group's shape a distance equal to the value of position.
  external b2Vec2 position;

  /// The world angle of the group in radians.
  /// Rotates the shape by an angle equal to the value of angle.
  @ffi.Float()
  external double angle;

  /// The linear velocity of the group's origin in world co-ordinates.
  external b2Vec2 linearVelocity;

  /// The angular velocity of the group.
  @ffi.Float()
  external double angularVelocity;

  /// The color of all particles in the group.
  @ffi.Int32()
  external int color;

  /// The strength of cohesion among the particles in a group with flag
  /// b2_elasticParticle or b2_springParticle.
  @ffi.Float()
  external double strength;

  /// The shape where particles will be added.
  external ffi.Pointer<ffi.Int32> shape;

  /// A array of shapes where particles will be added.
  external ffi.Pointer<ffi.Pointer<ffi.Int32>> shapes;

  /// The number of shapes.
  @int32()
  external int shapeCount;

  /// The interval of particles in the shape.
  /// If it is 0, b2_particleStride * particleDiameter is used instead.
  @ffi.Float()
  external double stride;

  /// The number of particles in addition to ones added in the shape.
  @int32()
  external int particleCount;

  /// The initial positions of the particleCount particles.
  external ffi.Pointer<b2Vec2> positionData;

  /// Lifetime of the particle group in seconds.  A value <= 0.0f indicates a
  /// particle group with infinite lifetime.
  @ffi.Float()
  external double lifetime;

  /// Use this to store application-specific group data.
  external ffi.Pointer<ffi.Void> userData;

  /// An existing particle group to which the particles will be added.
  external ffi.Pointer<ffi.Int32> group;
}

class FindContactInput extends ffi.Opaque {}

class FindContactCheck extends ffi.Opaque {}

/// Connection between two particles
class b2ParticlePair extends ffi.Struct {
  /// Indices of the respective particles making pair.
  @int32()
  external int indexA;

  @int32()
  external int indexB;

  /// The logical sum of the particle flags. See the b2ParticleFlag enum.
  @uint32()
  external int flags;

  /// The strength of cohesion among the particles.
  @ffi.Float()
  external double strength;

  /// The initial distance of the particles.
  @ffi.Float()
  external double distance;
}

/// Connection between three particles
class b2ParticleTriad extends ffi.Struct {
  /// Indices of the respective particles making triad.
  @int32()
  external int indexA;

  @int32()
  external int indexB;

  @int32()
  external int indexC;

  /// The logical sum of the particle flags. See the b2ParticleFlag enum.
  @uint32()
  external int flags;

  /// The strength of cohesion among the particles.
  @ffi.Float()
  external double strength;

  /// Values used for calculation.
  external b2Vec2 pa;

  external b2Vec2 pb;

  external b2Vec2 pc;

  @ffi.Float()
  external double ka;

  @ffi.Float()
  external double kb;

  @ffi.Float()
  external double kc;

  @ffi.Float()
  external double s;
}

class b2ParticleSystemDef extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2ParticleSystemDef1;

  /// Set the particle density.
  /// See SetDensity for details.
  @ffi.Float()
  external double density;

  /// Change the particle gravity scale. Adjusts the effect of the global
  /// gravity vector on particles. Default value is 1.0f.
  @ffi.Float()
  external double gravityScale;

  /// Particles behave as circles with this radius. In Box2D units.
  @ffi.Float()
  external double radius;

  /// Set the maximum number of particles.
  /// By default, there is no maximum. The particle buffers can continue to
  /// grow while b2World's block allocator still has memory.
  /// See SetMaxParticleCount for details.
  @int32()
  external int maxCount;

  /// Increases pressure in response to compression
  /// Smaller values allow more compression
  @ffi.Float()
  external double pressureStrength;

  /// Reduces velocity along the collision normal
  /// Smaller value reduces less
  @ffi.Float()
  external double dampingStrength;

  /// Restores shape of elastic particle groups
  /// Larger values increase elastic particle velocity
  @ffi.Float()
  external double elasticStrength;

  /// Restores length of spring particle groups
  /// Larger values increase spring particle velocity
  @ffi.Float()
  external double springStrength;

  /// Reduces relative velocity of viscous particles
  /// Larger values slow down viscous particles more
  @ffi.Float()
  external double viscousStrength;

  /// Produces pressure on tensile particles
  /// 0~0.2. Larger values increase the amount of surface tension.
  @ffi.Float()
  external double surfaceTensionPressureStrength;

  /// Smoothes outline of tensile particles
  /// 0~0.2. Larger values result in rounder, smoother, water-drop-like
  /// clusters of particles.
  @ffi.Float()
  external double surfaceTensionNormalStrength;

  /// Produces additional pressure on repulsive particles
  /// Larger values repulse more
  /// Negative values mean attraction. The range where particles behave
  /// stably is about -0.2 to 2.0.
  @ffi.Float()
  external double repulsiveStrength;

  /// Produces repulsion between powder particles
  /// Larger values repulse more
  @ffi.Float()
  external double powderStrength;

  /// Pushes particles out of solid particle group
  /// Larger values repulse more
  @ffi.Float()
  external double ejectionStrength;

  /// Produces static pressure
  /// Larger values increase the pressure on neighboring partilces
  /// For a description of static pressure, see
  /// http://en.wikipedia.org/wiki/Static_pressure#Static_pressure_in_fluid_dynamics
  @ffi.Float()
  external double staticPressureStrength;

  /// Reduces instability in static pressure calculation
  /// Larger values make stabilize static pressure with fewer iterations
  @ffi.Float()
  external double staticPressureRelaxation;

  /// Computes static pressure more precisely
  /// See SetStaticPressureIterations for details
  @int32()
  external int staticPressureIterations;

  /// Determines how fast colors are mixed
  /// 1.0f ==> mixed immediately
  /// 0.5f ==> mixed half way each simulation step (see b2World::Step())
  @ffi.Float()
  external double colorMixingStrength;

  /// Whether to destroy particles by age when no more particles can be
  /// created.  See #b2ParticleSystem::SetDestructionByAge() for
  /// more information.
  @ffi.Int32()
  external int destroyByAge;

  /// Granularity of particle lifetimes in seconds.  By default this is
  /// set to (1.0f / 60.0f) seconds.  b2ParticleSystem uses a 32-bit signed
  /// value to track particle lifetimes so the maximum lifetime of a
  /// particle is (2^32 - 1) / (1.0f / lifetimeGranularity) seconds.
  /// With the value set to 1/60 the maximum lifetime or age of a particle is
  /// 2.27 years.
  @ffi.Float()
  external double lifetimeGranularity;
}

/// Joint definitions are used to construct joints.
class b2JointDef extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2JointDef1;

  /// Use this to attach application specific data to your joints.
  external b2JointUserData userData;

  /// The first attached body.
  external ffi.Pointer<ffi.Int32> bodyA;

  /// The second attached body.
  external ffi.Pointer<ffi.Int32> bodyB;

  /// Set this flag to true if the attached bodies should collide.
  @ffi.Int32()
  external int collideConnected;
}

abstract class b2JointType {
  static const int e_unknownJoint = 0;
  static const int e_revoluteJoint = 1;
  static const int e_prismaticJoint = 2;
  static const int e_distanceJoint = 3;
  static const int e_pulleyJoint = 4;
  static const int e_mouseJoint = 5;
  static const int e_gearJoint = 6;
  static const int e_wheelJoint = 7;
  static const int e_weldJoint = 8;
  static const int e_frictionJoint = 9;
  static const int e_ropeJoint = 10;
  static const int e_motorJoint = 11;
}

class b2Jacobian extends ffi.Struct {
  external b2Vec2 linear;

  @ffi.Float()
  external double angularA;

  @ffi.Float()
  external double angularB;
}

/// Distance joint definition. This requires defining an anchor point on both
/// bodies and the non-zero distance of the distance joint. The definition uses
/// local anchor points so that the initial configuration can violate the
/// constraint slightly. This helps when saving and loading a game.
class b2DistanceJointDef extends ffi.Opaque {}

/// Friction joint definition.
class b2FrictionJointDef extends ffi.Opaque {}

/// Gear joint definition. This definition requires two existing
/// revolute or prismatic joints (any combination will work).
/// @warning bodyB on the input joints must both be dynamic
class b2GearJointDef extends ffi.Opaque {}

/// Motor joint definition.
class b2MotorJointDef extends ffi.Opaque {}

/// Mouse joint definition. This requires a world target point,
/// tuning parameters, and the time step.
class b2MouseJointDef extends ffi.Opaque {}

/// Prismatic joint definition. This requires defining a line of
/// motion using an axis and an anchor point. The definition uses local
/// anchor points and a local axis so that the initial configuration
/// can violate the constraint slightly. The joint translation is zero
/// when the local anchor points coincide in world space. Using local
/// anchors and a local axis helps when saving and loading a game.
class b2PrismaticJointDef extends ffi.Opaque {}

/// Pulley joint definition. This requires two ground anchors,
/// two dynamic body anchor points, and a pulley ratio.
class b2PulleyJointDef extends ffi.Opaque {}

/// Revolute joint definition. This requires defining an anchor point where the
/// bodies are joined. The definition uses local anchor points so that the
/// initial configuration can violate the constraint slightly. You also need to
/// specify the initial relative angle for joint limits. This helps when saving
/// and loading a game.
/// The local anchor points are measured from the body's origin
/// rather than the center of mass because:
/// 1. you might not know where the center of mass will be.
/// 2. if you add/remove shapes from a body and recompute the mass,
/// the joints will be broken.
class b2RevoluteJointDef extends ffi.Opaque {}

/// Weld joint definition. You need to specify local anchor points
/// where they are attached and the relative body angle. The position
/// of the anchor points is important for computing the reaction torque.
class b2WeldJointDef extends ffi.Opaque {}

/// Wheel joint definition. This requires defining a line of
/// motion using an axis and an anchor point. The definition uses local
/// anchor points and a local axis so that the initial configuration
/// can violate the constraint slightly. The joint translation is zero
/// when the local anchor points coincide in world space. Using local
/// anchors and a local axis helps when saving and loading a game.
class b2WheelJointDef extends ffi.Opaque {}

/// The particle group type.  Can be combined with the | operator.
abstract class b2ParticleGroupFlag {
  /// Prevents overlapping or leaking.
  static const int b2_solidParticleGroup = 1;

  /// Keeps its shape.
  static const int b2_rigidParticleGroup = 2;

  /// Won't be destroyed if it gets empty.
  static const int b2_particleGroupCanBeEmpty = 4;

  /// Will be destroyed on next simulation step.
  static const int b2_particleGroupWillBeDestroyed = 8;

  /// Updates depth data on next simulation step.
  static const int b2_particleGroupNeedsUpdateDepth = 16;
  static const int b2_particleGroupInternalMask = 24;
}

class b2RopeStretch extends ffi.Opaque {}

class b2RopeBend extends ffi.Opaque {}

abstract class b2StretchingModel {
  static const int b2_pbdStretchingModel = 0;
  static const int b2_xpbdStretchingModel = 1;
}

abstract class b2BendingModel {
  static const int b2_springAngleBendingModel = 0;
  static const int b2_pbdAngleBendingModel = 1;
  static const int b2_xpbdAngleBendingModel = 2;
  static const int b2_pbdDistanceBendingModel = 3;
  static const int b2_pbdHeightBendingModel = 4;
  static const int b2_pbdTriangleBendingModel = 5;
}

///
class b2RopeTuning extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2RopeTuning1;

  @ffi.Int32()
  external int bendingModel;

  @ffi.Float()
  external double damping;

  @ffi.Float()
  external double stretchStiffness;

  @ffi.Float()
  external double stretchHertz;

  @ffi.Float()
  external double stretchDamping;

  @ffi.Float()
  external double bendStiffness;

  @ffi.Float()
  external double bendHertz;

  @ffi.Float()
  external double bendDamping;

  @ffi.Int32()
  external int isometric;

  @ffi.Int32()
  external int fixedEffectiveMass;

  @ffi.Int32()
  external int warmStart;
}

///
class b2RopeDef extends ffi.Struct {
  @ffi.NativeFunction<ffi.Int32 Function()>()
  external ffi.NativeFunction<int Function()> b2RopeDef1;

  external ffi.Pointer<b2Vec2> vertices;

  @int32()
  external int count;

  external ffi.Pointer<ffi.Float> masses;

  external b2Vec2 gravity;

  external b2RopeTuning tuning;
}

const double b2_lengthUnitsPerMeter = 1.0;

const int b2_maxPolygonVertices = 8;

const int B2_ASSERT_ENABLED = 0;

const double b2_maxFloat = 3.4028234663852886e+38;

const double b2_epsilon = 1.1920928955078125e-7;

const double b2_pi = 3.1415927410125732;

const int LIQUIDFUN_EXTERNAL_LANGUAGE_API = 0;

const int b2_maxManifoldPoints = 2;

const double b2_aabbExtension = 0.10000000149011612;

const double b2_aabbMultiplier = 4.0;

const double b2_linearSlop = 0.004999999888241291;

const double b2_angularSlop = 0.03490658849477768;

const double b2_polygonRadius = 0.009999999776482582;

const int b2_maxSubSteps = 8;

const int b2_maxTOIContacts = 32;

const double b2_maxLinearCorrection = 0.20000000298023224;

const double b2_maxAngularCorrection = 0.13962635397911072;

const double b2_maxTranslation = 2.0;

const double b2_maxTranslationSquared = 4.0;

const double b2_maxRotation = 1.5707963705062866;

const double b2_maxRotationSquared = 2.4674012660980225;

const double b2_baumgarte = 0.20000000298023224;

const double b2_toiBaumgarte = 0.75;

const int b2_invalidParticleIndex = -1;

const int b2_maxParticleIndex = 2147483647;

const double b2_particleStride = 0.75;

const double b2_minParticleWeight = 1.0;

const double b2_maxParticlePressure = 0.25;

const double b2_maxParticleForce = 0.5;

const int b2_maxTriadDistance = 2;

const int b2_maxTriadDistanceSquared = 4;

const int b2_minParticleSystemBufferCapacity = 256;

const double b2_barrierCollisionTime = 2.5;

const double b2_timeToSleep = 0.5;

const double b2_linearSleepTolerance = 0.009999999776482582;

const double b2_angularSleepTolerance = 0.03490658849477768;

const int B2_INTRUSIVE_LIST_VALIDATE = 0;

const int b2_nullNode = -1;

const int B2_FREE_LIST_CHECK_ALLOCATED_ON_FREE = 0;
