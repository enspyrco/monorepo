// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for `src/flutter_box2c.h`.
class FlutterBox2cBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FlutterBox2cBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FlutterBox2cBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<b2WorldId> _b2_nullWorldId =
      _lookup<b2WorldId>('b2_nullWorldId');

  b2WorldId get b2_nullWorldId => _b2_nullWorldId.ref;

  late final ffi.Pointer<b2BodyId> _b2_nullBodyId =
      _lookup<b2BodyId>('b2_nullBodyId');

  b2BodyId get b2_nullBodyId => _b2_nullBodyId.ref;

  late final ffi.Pointer<b2ShapeId> _b2_nullShapeId =
      _lookup<b2ShapeId>('b2_nullShapeId');

  b2ShapeId get b2_nullShapeId => _b2_nullShapeId.ref;

  late final ffi.Pointer<b2JointId> _b2_nullJointId =
      _lookup<b2JointId>('b2_nullJointId');

  b2JointId get b2_nullJointId => _b2_nullJointId.ref;

  /// box2d bases all length units on meters, but you may need different units for your game.
  /// You can adjust this value to use different units, normally at application startup.
  late final ffi.Pointer<ffi.Float> _b2_lengthUnitsPerMeter =
      _lookup<ffi.Float>('b2_lengthUnitsPerMeter');

  double get b2_lengthUnitsPerMeter => _b2_lengthUnitsPerMeter.value;

  set b2_lengthUnitsPerMeter(double value) =>
      _b2_lengthUnitsPerMeter.value = value;

  /// The time that a body must be still before it will go to sleep.
  late final ffi.Pointer<ffi.Float> _b2_timeToSleep =
      _lookup<ffi.Float>('b2_timeToSleep');

  double get b2_timeToSleep => _b2_timeToSleep.value;

  set b2_timeToSleep(double value) => _b2_timeToSleep.value = value;

  /// Current version.
  late final ffi.Pointer<b2Version> _b2_version =
      _lookup<b2Version>('b2_version');

  b2Version get b2_version => _b2_version.ref;

  late final ffi.Pointer<b2Filter> _b2_defaultFilter =
      _lookup<b2Filter>('b2_defaultFilter');

  b2Filter get b2_defaultFilter => _b2_defaultFilter.ref;

  /// Create a world for rigid body simulation. This contains all the bodies, shapes, and constraints.
  b2WorldId b2CreateWorld(
    ffi.Pointer<b2WorldDef> def,
  ) {
    return _b2CreateWorld(
      def,
    );
  }

  late final _b2CreateWorldPtr =
      _lookup<ffi.NativeFunction<b2WorldId Function(ffi.Pointer<b2WorldDef>)>>(
          'b2CreateWorld');
  late final _b2CreateWorld = _b2CreateWorldPtr
      .asFunction<b2WorldId Function(ffi.Pointer<b2WorldDef>)>();

  /// Destroy a world.
  void b2DestroyWorld(
    b2WorldId worldId,
  ) {
    return _b2DestroyWorld(
      worldId,
    );
  }

  late final _b2DestroyWorldPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(b2WorldId)>>(
          'b2DestroyWorld');
  late final _b2DestroyWorld =
      _b2DestroyWorldPtr.asFunction<void Function(b2WorldId)>();

  /// Take a time step. This performs collision detection, integration,
  /// and constraint solution.
  /// @param timeStep the amount of time to simulate, this should not vary.
  /// @param velocityIterations for the velocity constraint solver.
  /// @param positionIterations for the position constraint solver.
  void b2World_Step(
    b2WorldId worldId,
    double timeStep,
    int velocityIterations,
    int positionIterations,
  ) {
    return _b2World_Step(
      worldId,
      timeStep,
      velocityIterations,
      positionIterations,
    );
  }

  late final _b2World_StepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              b2WorldId, ffi.Float, ffi.Int32, ffi.Int32)>>('b2World_Step');
  late final _b2World_Step =
      _b2World_StepPtr.asFunction<void Function(b2WorldId, double, int, int)>();

  /// Call this to draw shapes and other debug draw data. This is intentionally non-const.
  void b2World_Draw(
    b2WorldId worldId,
    ffi.Pointer<b2DebugDraw> debugDraw,
  ) {
    return _b2World_Draw(
      worldId,
      debugDraw,
    );
  }

  late final _b2World_DrawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              b2WorldId, ffi.Pointer<b2DebugDraw>)>>('b2World_Draw');
  late final _b2World_Draw = _b2World_DrawPtr
      .asFunction<void Function(b2WorldId, ffi.Pointer<b2DebugDraw>)>();

  /// Enable/disable sleep.
  void b2World_EnableSleeping(
    b2WorldId worldId,
    bool flag,
  ) {
    return _b2World_EnableSleeping(
      worldId,
      flag,
    );
  }

  late final _b2World_EnableSleepingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(b2WorldId, ffi.Bool)>>(
          'b2World_EnableSleeping');
  late final _b2World_EnableSleeping =
      _b2World_EnableSleepingPtr.asFunction<void Function(b2WorldId, bool)>();

  /// Get the current profile.
  ffi.Pointer<b2Profile> b2World_GetProfile(
    b2WorldId worldId,
  ) {
    return _b2World_GetProfile(
      worldId,
    );
  }

  late final _b2World_GetProfilePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<b2Profile> Function(b2WorldId)>>(
          'b2World_GetProfile');
  late final _b2World_GetProfile = _b2World_GetProfilePtr
      .asFunction<ffi.Pointer<b2Profile> Function(b2WorldId)>();

  b2BodyId b2World_GetGroundBodyId(
    b2WorldId worldId,
  ) {
    return _b2World_GetGroundBodyId(
      worldId,
    );
  }

  late final _b2World_GetGroundBodyIdPtr =
      _lookup<ffi.NativeFunction<b2BodyId Function(b2WorldId)>>(
          'b2World_GetGroundBodyId');
  late final _b2World_GetGroundBodyId =
      _b2World_GetGroundBodyIdPtr.asFunction<b2BodyId Function(b2WorldId)>();

  /// Create a rigid body given a definition. No reference to the definition is retained.
  /// @warning This function is locked during callbacks.
  b2BodyId b2World_CreateBody(
    b2WorldId worldId,
    ffi.Pointer<b2BodyDef> def,
  ) {
    return _b2World_CreateBody(
      worldId,
      def,
    );
  }

  late final _b2World_CreateBodyPtr = _lookup<
      ffi.NativeFunction<
          b2BodyId Function(
              b2WorldId, ffi.Pointer<b2BodyDef>)>>('b2World_CreateBody');
  late final _b2World_CreateBody = _b2World_CreateBodyPtr
      .asFunction<b2BodyId Function(b2WorldId, ffi.Pointer<b2BodyDef>)>();

  /// Destroy a rigid body given an id.
  /// @warning This function is locked during callbacks.
  void b2World_DestroyBody(
    b2BodyId bodyId,
  ) {
    return _b2World_DestroyBody(
      bodyId,
    );
  }

  late final _b2World_DestroyBodyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(b2BodyId)>>(
          'b2World_DestroyBody');
  late final _b2World_DestroyBody =
      _b2World_DestroyBodyPtr.asFunction<void Function(b2BodyId)>();

  b2Vec2 b2Body_GetPosition(
    b2BodyId bodyId,
  ) {
    return _b2Body_GetPosition(
      bodyId,
    );
  }

  late final _b2Body_GetPositionPtr =
      _lookup<ffi.NativeFunction<b2Vec2 Function(b2BodyId)>>(
          'b2Body_GetPosition');
  late final _b2Body_GetPosition =
      _b2Body_GetPositionPtr.asFunction<b2Vec2 Function(b2BodyId)>();

  double b2Body_GetAngle(
    b2BodyId bodyId,
  ) {
    return _b2Body_GetAngle(
      bodyId,
    );
  }

  late final _b2Body_GetAnglePtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(b2BodyId)>>(
          'b2Body_GetAngle');
  late final _b2Body_GetAngle =
      _b2Body_GetAnglePtr.asFunction<double Function(b2BodyId)>();

  b2Vec2 b2Body_GetLocalPoint(
    b2BodyId bodyId,
    b2Vec2 globalPoint,
  ) {
    return _b2Body_GetLocalPoint(
      bodyId,
      globalPoint,
    );
  }

  late final _b2Body_GetLocalPointPtr =
      _lookup<ffi.NativeFunction<b2Vec2 Function(b2BodyId, b2Vec2)>>(
          'b2Body_GetLocalPoint');
  late final _b2Body_GetLocalPoint =
      _b2Body_GetLocalPointPtr.asFunction<b2Vec2 Function(b2BodyId, b2Vec2)>();

  int b2Body_GetType(
    b2BodyId bodyId,
  ) {
    return _b2Body_GetType(
      bodyId,
    );
  }

  late final _b2Body_GetTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(b2BodyId)>>(
          'b2Body_GetType');
  late final _b2Body_GetType =
      _b2Body_GetTypePtr.asFunction<int Function(b2BodyId)>();

  double b2Body_GetMass(
    b2BodyId bodyId,
  ) {
    return _b2Body_GetMass(
      bodyId,
    );
  }

  late final _b2Body_GetMassPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(b2BodyId)>>(
          'b2Body_GetMass');
  late final _b2Body_GetMass =
      _b2Body_GetMassPtr.asFunction<double Function(b2BodyId)>();

  void b2Body_SetAwake(
    b2BodyId bodyId,
    bool awake,
  ) {
    return _b2Body_SetAwake(
      bodyId,
      awake,
    );
  }

  late final _b2Body_SetAwakePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(b2BodyId, ffi.Bool)>>(
          'b2Body_SetAwake');
  late final _b2Body_SetAwake =
      _b2Body_SetAwakePtr.asFunction<void Function(b2BodyId, bool)>();

  /// Create a shape and attach it to a body. Contacts are not created until the next time step.
  /// @warning This function is locked during callbacks.
  b2ShapeId b2Body_CreateCircle(
    b2BodyId bodyId,
    ffi.Pointer<b2ShapeDef> def,
    ffi.Pointer<b2Circle> circle,
  ) {
    return _b2Body_CreateCircle(
      bodyId,
      def,
      circle,
    );
  }

  late final _b2Body_CreateCirclePtr = _lookup<
      ffi.NativeFunction<
          b2ShapeId Function(b2BodyId, ffi.Pointer<b2ShapeDef>,
              ffi.Pointer<b2Circle>)>>('b2Body_CreateCircle');
  late final _b2Body_CreateCircle = _b2Body_CreateCirclePtr.asFunction<
      b2ShapeId Function(
          b2BodyId, ffi.Pointer<b2ShapeDef>, ffi.Pointer<b2Circle>)>();

  b2ShapeId b2Body_CreatePolygon(
    b2BodyId bodyId,
    ffi.Pointer<b2ShapeDef> def,
    ffi.Pointer<b2Polygon> polygon,
  ) {
    return _b2Body_CreatePolygon(
      bodyId,
      def,
      polygon,
    );
  }

  late final _b2Body_CreatePolygonPtr = _lookup<
      ffi.NativeFunction<
          b2ShapeId Function(b2BodyId, ffi.Pointer<b2ShapeDef>,
              ffi.Pointer<b2Polygon>)>>('b2Body_CreatePolygon');
  late final _b2Body_CreatePolygon = _b2Body_CreatePolygonPtr.asFunction<
      b2ShapeId Function(
          b2BodyId, ffi.Pointer<b2ShapeDef>, ffi.Pointer<b2Polygon>)>();

  b2BodyId b2Shape_GetBody(
    b2ShapeId shapeId,
  ) {
    return _b2Shape_GetBody(
      shapeId,
    );
  }

  late final _b2Shape_GetBodyPtr =
      _lookup<ffi.NativeFunction<b2BodyId Function(b2ShapeId)>>(
          'b2Shape_GetBody');
  late final _b2Shape_GetBody =
      _b2Shape_GetBodyPtr.asFunction<b2BodyId Function(b2ShapeId)>();

  bool b2Shape_TestPoint(
    b2ShapeId shapeId,
    b2Vec2 point,
  ) {
    return _b2Shape_TestPoint(
      shapeId,
      point,
    );
  }

  late final _b2Shape_TestPointPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(b2ShapeId, b2Vec2)>>(
          'b2Shape_TestPoint');
  late final _b2Shape_TestPoint =
      _b2Shape_TestPointPtr.asFunction<bool Function(b2ShapeId, b2Vec2)>();

  b2JointId b2World_CreateMouseJoint(
    b2WorldId worldId,
    ffi.Pointer<b2MouseJointDef> def,
  ) {
    return _b2World_CreateMouseJoint(
      worldId,
      def,
    );
  }

  late final _b2World_CreateMouseJointPtr = _lookup<
      ffi.NativeFunction<
          b2JointId Function(b2WorldId,
              ffi.Pointer<b2MouseJointDef>)>>('b2World_CreateMouseJoint');
  late final _b2World_CreateMouseJoint =
      _b2World_CreateMouseJointPtr.asFunction<
          b2JointId Function(b2WorldId, ffi.Pointer<b2MouseJointDef>)>();

  b2JointId b2World_CreateRevoluteJoint(
    b2WorldId worldId,
    ffi.Pointer<b2RevoluteJointDef> def,
  ) {
    return _b2World_CreateRevoluteJoint(
      worldId,
      def,
    );
  }

  late final _b2World_CreateRevoluteJointPtr = _lookup<
      ffi.NativeFunction<
          b2JointId Function(b2WorldId,
              ffi.Pointer<b2RevoluteJointDef>)>>('b2World_CreateRevoluteJoint');
  late final _b2World_CreateRevoluteJoint =
      _b2World_CreateRevoluteJointPtr.asFunction<
          b2JointId Function(b2WorldId, ffi.Pointer<b2RevoluteJointDef>)>();

  void b2World_DestroyJoint(
    b2JointId jointId,
  ) {
    return _b2World_DestroyJoint(
      jointId,
    );
  }

  late final _b2World_DestroyJointPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(b2JointId)>>(
          'b2World_DestroyJoint');
  late final _b2World_DestroyJoint =
      _b2World_DestroyJointPtr.asFunction<void Function(b2JointId)>();

  void b2MouseJoint_SetTarget(
    b2JointId jointId,
    b2Vec2 target,
  ) {
    return _b2MouseJoint_SetTarget(
      jointId,
      target,
    );
  }

  late final _b2MouseJoint_SetTargetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(b2JointId, b2Vec2)>>(
          'b2MouseJoint_SetTarget');
  late final _b2MouseJoint_SetTarget =
      _b2MouseJoint_SetTargetPtr.asFunction<void Function(b2JointId, b2Vec2)>();

  void b2RevoluteJoint_EnableLimit(
    b2JointId jointId,
    bool enableLimit,
  ) {
    return _b2RevoluteJoint_EnableLimit(
      jointId,
      enableLimit,
    );
  }

  late final _b2RevoluteJoint_EnableLimitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(b2JointId, ffi.Bool)>>(
          'b2RevoluteJoint_EnableLimit');
  late final _b2RevoluteJoint_EnableLimit = _b2RevoluteJoint_EnableLimitPtr
      .asFunction<void Function(b2JointId, bool)>();

  void b2RevoluteJoint_EnableMotor(
    b2JointId jointId,
    bool enableMotor,
  ) {
    return _b2RevoluteJoint_EnableMotor(
      jointId,
      enableMotor,
    );
  }

  late final _b2RevoluteJoint_EnableMotorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(b2JointId, ffi.Bool)>>(
          'b2RevoluteJoint_EnableMotor');
  late final _b2RevoluteJoint_EnableMotor = _b2RevoluteJoint_EnableMotorPtr
      .asFunction<void Function(b2JointId, bool)>();

  void b2RevoluteJoint_SetMotorSpeed(
    b2JointId jointId,
    double motorSpeed,
  ) {
    return _b2RevoluteJoint_SetMotorSpeed(
      jointId,
      motorSpeed,
    );
  }

  late final _b2RevoluteJoint_SetMotorSpeedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(b2JointId, ffi.Float)>>(
          'b2RevoluteJoint_SetMotorSpeed');
  late final _b2RevoluteJoint_SetMotorSpeed = _b2RevoluteJoint_SetMotorSpeedPtr
      .asFunction<void Function(b2JointId, double)>();

  double b2RevoluteJoint_GetMotorTorque(
    b2JointId jointId,
    double inverseTimeStep,
  ) {
    return _b2RevoluteJoint_GetMotorTorque(
      jointId,
      inverseTimeStep,
    );
  }

  late final _b2RevoluteJoint_GetMotorTorquePtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(b2JointId, ffi.Float)>>(
          'b2RevoluteJoint_GetMotorTorque');
  late final _b2RevoluteJoint_GetMotorTorque =
      _b2RevoluteJoint_GetMotorTorquePtr
          .asFunction<double Function(b2JointId, double)>();

  /// Query the world for all shapse that potentially overlap the provided AABB.
  /// @param callback a user implemented callback function.
  /// @param aabb the query box.
  void b2World_QueryAABB(
    b2WorldId worldId,
    b2AABB aabb,
    ffi.Pointer<b2QueryCallbackFcn> fcn,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _b2World_QueryAABB(
      worldId,
      aabb,
      fcn,
      context,
    );
  }

  late final _b2World_QueryAABBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(b2WorldId, b2AABB, ffi.Pointer<b2QueryCallbackFcn>,
              ffi.Pointer<ffi.Void>)>>('b2World_QueryAABB');
  late final _b2World_QueryAABB = _b2World_QueryAABBPtr.asFunction<
      void Function(b2WorldId, b2AABB, ffi.Pointer<b2QueryCallbackFcn>,
          ffi.Pointer<ffi.Void>)>();
}

/// mbstate_t is an opaque object to keep conversion state, during multibyte
/// stream conversions.  The content must not be referenced by user programs.
class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  /// for alignment
  @ffi.LongLong()
  external int _mbstateL;
}

class __darwin_pthread_handler_rec extends ffi.Struct {
  /// Routine to call
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  /// Argument to pass
  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

/// References a world instance
class b2WorldId extends ffi.Struct {
  @ffi.Int16()
  external int index;

  @ffi.Uint16()
  external int revision;
}

/// References a rigid body instance
class b2BodyId extends ffi.Struct {
  @ffi.Int32()
  external int index;

  @ffi.Int16()
  external int world;

  @ffi.Uint16()
  external int revision;
}

/// References a shape instance
class b2ShapeId extends ffi.Struct {
  @ffi.Int32()
  external int index;

  @ffi.Int16()
  external int world;

  @ffi.Uint16()
  external int revision;
}

/// References a joint instance
class b2JointId extends ffi.Struct {
  @ffi.Int32()
  external int index;

  @ffi.Int16()
  external int world;

  @ffi.Uint16()
  external int revision;
}

/// Version numbering scheme.
/// See http://en.wikipedia.org/wiki/Software_versioning
class b2Version extends ffi.Struct {
  @ffi.Int()
  external int major;

  @ffi.Int()
  external int minor;

  @ffi.Int()
  external int revision;
}

/// 2D vector
class b2Vec2 extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

/// 2D rotation
class b2Rot extends ffi.Struct {
  /// Sine and cosine
  @ffi.Float()
  external double s;

  @ffi.Float()
  external double c;
}

/// A 2D rigid transform
class b2Transform extends ffi.Struct {
  external b2Vec2 p;

  external b2Rot q;
}

/// A 2-by-2 Matrix
class b2Mat22 extends ffi.Struct {
  /// columns
  external b2Vec2 cx;

  external b2Vec2 cy;
}

/// Axis-aligned bounding box
class b2AABB extends ffi.Struct {
  external b2Vec2 lowerBound;

  external b2Vec2 upperBound;
}

/// Color for debug drawing. Each value has the range [0,1].
class b2Color extends ffi.Struct {
  @ffi.Float()
  external double r;

  @ffi.Float()
  external double g;

  @ffi.Float()
  external double b;

  @ffi.Float()
  external double a;
}

/// Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
class b2RayCastInput extends ffi.Struct {
  external b2Vec2 p1;

  external b2Vec2 p2;

  @ffi.Float()
  external double maxFraction;
}

/// Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from b2RayCastInput.
class b2RayCastOutput extends ffi.Struct {
  external b2Vec2 normal;

  @ffi.Float()
  external double fraction;

  @ffi.Bool()
  external bool hit;
}

class b2WorldDef extends ffi.Struct {
  /// Gravity vector. Box2D has no up-vector defined.
  external b2Vec2 gravity;

  /// Restitution velocity threshold, usually in m/s. Collisions above this
  /// speed have restitution applied (will bounce).
  @ffi.Float()
  external double restitutionThreshold;

  /// Can bodies go to sleep to improve performance
  @ffi.Bool()
  external bool enableSleep;

  /// initial capacity for bodies
  @ffi.Int32()
  external int bodyCapacity;

  /// initial capacity for joints
  @ffi.Int32()
  external int jointCapacity;

  /// initial capacity for shapes
  @ffi.Int32()
  external int shapeCapacity;
}

/// The body type.
/// static: zero mass, zero velocity, may be manually moved
/// kinematic: zero mass, non-zero velocity set by user, moved by solver
/// dynamic: positive mass, non-zero velocity determined by forces, moved by solver
abstract class b2BodyType {
  static const int b2_staticBody = 0;
  static const int b2_kinematicBody = 1;
  static const int b2_dynamicBody = 2;
  static const int b2_bodyTypeCount = 3;
}

/// A body definition holds all the data needed to construct a rigid body.
/// You can safely re-use body definitions. Shapes are added to a body after construction.
class b2BodyDef extends ffi.Struct {
  /// The body type: static, kinematic, or dynamic.
  /// Note: if a dynamic body would have zero mass, the mass is set to one.
  @ffi.Int32()
  external int type;

  /// The world position of the body. Avoid creating bodies at the origin
  /// since this can lead to many overlapping shapes.
  external b2Vec2 position;

  /// The world angle of the body in radians.
  @ffi.Float()
  external double angle;

  /// The linear velocity of the body's origin in world co-ordinates.
  external b2Vec2 linearVelocity;

  /// The angular velocity of the body.
  @ffi.Float()
  external double angularVelocity;

  /// Linear damping is use to reduce the linear velocity. The damping parameter
  /// can be larger than 1.0f but the damping effect becomes sensitive to the
  /// time step when the damping parameter is large.
  @ffi.Float()
  external double linearDamping;

  /// Angular damping is use to reduce the angular velocity. The damping parameter
  /// can be larger than 1.0f but the damping effect becomes sensitive to the
  /// time step when the damping parameter is large.
  @ffi.Float()
  external double angularDamping;

  /// Scale the gravity applied to this body.
  @ffi.Float()
  external double gravityScale;

  /// Use this to store application specific body data.
  external ffi.Pointer<ffi.Void> userData;

  /// Set this flag to false if this body should never fall asleep. Note that
  /// this increases CPU usage.
  @ffi.Bool()
  external bool enableSleep;

  /// Is this body initially awake or sleeping?
  @ffi.Bool()
  external bool isAwake;

  /// Should this body be prevented from rotating? Useful for characters.
  @ffi.Bool()
  external bool fixedRotation;

  /// Does this body start out enabled?
  @ffi.Bool()
  external bool isEnabled;
}

/// This holds contact filtering data.
class b2Filter extends ffi.Struct {
  /// The collision category bits. Normally you would just set one bit.
  @ffi.Uint32()
  external int categoryBits;

  /// The collision mask bits. This states the categories that this
  /// shape would accept for collision.
  @ffi.Uint32()
  external int maskBits;

  /// Collision groups allow a certain group of objects to never collide (negative)
  /// or always collide (positive). Zero means no collision group. Non-zero group
  /// filtering always wins against the mask bits.
  @ffi.Int32()
  external int groupIndex;
}

/// Used to create a shape
class b2ShapeDef extends ffi.Struct {
  /// Use this to store application specific shape data.
  external ffi.Pointer<ffi.Void> userData;

  /// The friction coefficient, usually in the range [0,1].
  @ffi.Float()
  external double friction;

  /// The restitution (elasticity) usually in the range [0,1].
  @ffi.Float()
  external double restitution;

  /// The density, usually in kg/m^2.
  @ffi.Float()
  external double density;

  /// Contact filtering data.
  external b2Filter filter;

  /// A sensor shape collects contact information but never generates a collision
  /// response.
  @ffi.Bool()
  external bool isSensor;
}

/// A mouse joint is used to make a point on a body track a
/// specified world point. This a soft constraint with a maximum
/// force. This allows the constraint to stretch without
/// applying huge forces.
/// NOTE: this joint is not documented in the manual because it was
/// developed to be used in samples. If you want to learn how to
/// use the mouse joint, look at the samples app.
class b2MouseJointDef extends ffi.Struct {
  /// The attached body. It should be dynamic.
  external b2BodyId bodyId;

  /// The initial world target point. This is assumed
  /// to coincide with the body anchor initially.
  external b2Vec2 target;

  /// The maximum constraint force that can be exerted
  /// to move the candidate body. Usually you will express
  /// as some multiple of the weight (multiplier * mass * gravity).
  @ffi.Float()
  external double maxForce;

  /// The linear stiffness in N/m
  @ffi.Float()
  external double stiffness;

  /// The linear damping in N*s/m
  @ffi.Float()
  external double damping;
}

/// Revolute joint definition. This requires defining an anchor point where the
/// bodies are joined. The definition uses local anchor points so that the
/// initial configuration can violate the constraint slightly. You also need to
/// specify the initial relative angle for joint limits. This helps when saving
/// and loading a game.
/// The local anchor points are measured from the body's origin
/// rather than the center of mass because:
/// 1. you might not know where the center of mass will be.
/// 2. if you add/remove shapes from a body and recompute the mass,
/// the joints will be broken.
class b2RevoluteJointDef extends ffi.Struct {
  /// The first attached body.
  external b2BodyId bodyIdA;

  /// The second attached body.
  external b2BodyId bodyIdB;

  /// The local anchor point relative to bodyA's origin.
  external b2Vec2 localAnchorA;

  /// The local anchor point relative to bodyB's origin.
  external b2Vec2 localAnchorB;

  /// The bodyB angle minus bodyA angle in the reference state (radians).
  /// This defines the zero angle for the joint limit.
  @ffi.Float()
  external double referenceAngle;

  /// A flag to enable joint limits.
  @ffi.Bool()
  external bool enableLimit;

  /// The lower angle for the joint limit (radians).
  @ffi.Float()
  external double lowerAngle;

  /// The upper angle for the joint limit (radians).
  @ffi.Float()
  external double upperAngle;

  /// A flag to enable the joint motor.
  @ffi.Bool()
  external bool enableMotor;

  /// The desired motor speed. Usually in radians per second.
  @ffi.Float()
  external double motorSpeed;

  /// The maximum motor torque used to achieve the desired motor speed.
  /// Usually in N-m.
  @ffi.Float()
  external double maxMotorTorque;

  /// Set this flag to true if the attached bodies should collide.
  @ffi.Bool()
  external bool collideConnected;
}

class b2Circle extends ffi.Opaque {}

class b2Polygon extends ffi.Opaque {}

class b2DebugDraw extends ffi.Opaque {}

class b2Profile extends ffi.Opaque {}

/// This function receives shapes found in the AABB query.
/// @return true if the query should continue
typedef b2QueryCallbackFcn
    = ffi.NativeFunction<ffi.Bool Function(b2ShapeId, ffi.Pointer<ffi.Void>)>;

const int __WORDSIZE = 64;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const double b2_pi = 3.1415927410125732;

const double b2_angularSlop = 0.03490658849477768;

const int b2_maxPolygonVertices = 8;

const int b2_maxWorlds = 32;

const double b2_maxAngularCorrection = 0.13962635397911072;

const double b2_maxRotation = 1.5707963705062866;

const double b2_maxRotationSquared = 2.4674012660980225;

const double b2_baumgarte = 0.5;

const double b2_angularSleepTolerance = 0.03490658849477768;

const int true1 = 1;

const int false1 = 0;

const int __bool_true_false_are_defined = 1;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int B2_NULL_INDEX = -1;
